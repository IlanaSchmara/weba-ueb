'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceAt = exports.PaddedCounter = exports.CollisionCheck = exports.now = exports.parseYaml = exports.parseJson = exports.jsonStringify = exports.xor = exports.hasKeys = exports.isPromise = exports.isAsyncFunction = exports.isFunction = exports.isArray = exports.isInteger = exports.isDefined = void 0;
const YAML = require("yaml");
exports.isDefined = (a) => a != null;
exports.isInteger = Number.isInteger;
exports.isArray = Array.isArray;
//@see https://stackoverflow.com/a/7356528
exports.isFunction = (functionToCheck) => {
    return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
};
exports.isAsyncFunction = (functionToCheck) => {
    return functionToCheck && functionToCheck.constructor.name === 'AsyncFunction';
};
exports.isPromise = (p) => exports.isDefined(p) && exports.isDefined(p.then) && exports.isFunction(p.then);
exports.hasKeys = (v) => typeof v === 'object' && v !== null;
exports.xor = (a, b) => a ? !b : b;
exports.jsonStringify = (obj, newLine) => `${newLine ? '\n' : ''}${JSON.stringify(obj, null, 4)}`;
exports.parseJson = (raw) => {
    return JSON.parse(raw);
};
exports.parseYaml = (raw) => {
    return YAML.parse(raw);
};
exports.now = () => (new Date).toString();
class CollisionCheck {
    constructor() {
        this.list = [];
    }
    /**
     *
     * @param element element to verify, if it's already included
     * @returns true, if element is a new one
     */
    verify(element) {
        if (this.list.includes(element)) {
            return false;
        }
        this.list.push(element);
        return true;
    }
}
exports.CollisionCheck = CollisionCheck;
class PaddedCounter {
    constructor(start, end) {
        this.start = start;
        this.end = end;
        this.originalStart = this.start;
        this.end = exports.isDefined(end) ? end : Number.MAX_SAFE_INTEGER;
        this.maxLength = this.length(end);
    }
    length(n) {
        return `${n}`.length;
    }
    inc() {
        this.start = this.start >= this.end ? this.originalStart : this.start + 1;
    }
    padding(n) {
        let result = '';
        for (let i = this.length(n); i < this.maxLength; ++i) {
            result = `0${result}`;
        }
        return result;
    }
    next() {
        const n = this.start;
        const padding = this.padding(n);
        this.inc();
        return `${padding}${n}`;
    }
    getMaxLength() {
        return this.maxLength;
    }
}
exports.PaddedCounter = PaddedCounter;
exports.replaceAt = (str, index, replacement) => {
    return `${str.substr(0, index)}${replacement}${str.substr(index + replacement.length)}`;
};

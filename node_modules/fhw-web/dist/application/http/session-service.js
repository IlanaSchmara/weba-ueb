'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionService = exports.EmptySession = void 0;
const helper_1 = require("../helper");
const uuid_1 = require("uuid");
class Session {
    constructor(file) {
        this.file = file;
    }
    getId() {
        return this.file.id;
    }
    getMeta() {
        return {
            createdAt: this.file.meta.createdAt,
            lastAccess: {
                at: this.file.meta.lastAccess.at,
                url: this.file.meta.lastAccess.url
            }
        };
    }
    getData() {
        return JSON.parse(JSON.stringify(this.file.data));
    }
    save(data) {
        this.file.data = data;
    }
}
class EmptySession {
    constructor() { }
    getId() {
        return '';
    }
    getMeta() {
        return { createdAt: '', lastAccess: { at: '', url: '' } };
    }
    getData() {
        return {};
    }
    save(_data) { }
}
exports.EmptySession = EmptySession;
// TODO log a hint, if EmptySession is actively used by user
// TODO session-id should not contain local index
class SessionService {
    constructor(config, logging, fileUtils, req, res) {
        this.config = config;
        this.logging = logging;
        this.fileUtils = fileUtils;
        this.req = req;
        this.res = res;
    }
    prepare(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionsFolderExists = yield this.fileUtils.exist('sessions');
            if (!sessionsFolderExists) {
                yield this.fileUtils.mkdir('sessions');
            }
            const files = yield this.fileUtils.listFiles({ directory: 'sessions', recursively: false });
            const fileExist = files.includes(`${id}.json`);
            const minPadding = Math.max(99, files.length * 10);
            const padded = new helper_1.PaddedCounter(files.length + 1, minPadding);
            return helper_1.isDefined(id)
                ? [fileExist, id]
                : [fileExist, `${padded.next()}-${uuid_1.v4()}`];
        });
    }
    writeSession(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = {
                id: this.session.getId(),
                meta: this.session.getMeta(),
                data: Object.assign(Object.assign(Object.assign(Object.assign({}, this.session.getData()), request.path), request.get), request.post)
            };
            return this.fileUtils.writeJson(file, this.session.getId(), 'sessions');
        });
    }
    readSession(url, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionFile = yield this.fileUtils.readJson(id, 'sessions');
            sessionFile.meta.lastAccess = { at: helper_1.now(), url };
            this.session = new Session(sessionFile);
            return this.session;
        });
    }
    initSession(url, existingId) {
        return __awaiter(this, void 0, void 0, function* () {
            const datetime = helper_1.now();
            const [_, id] = yield this.prepare(existingId);
            const meta = { createdAt: datetime, lastAccess: { at: datetime, url } };
            const data = {};
            this.session = new Session({ id, meta, data });
            return this.session;
        });
    }
    openSession(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const [fileExists, id] = yield this.prepare(this.req.cookies['session-id']);
            return fileExists
                ? yield this.readSession(url, id)
                : yield this.initSession(url, id);
        });
    }
    closeSession(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.active) {
                yield this.writeSession(request);
                this.res.cookie('session-id', this.session.getId());
            }
        });
    }
    getSession(url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.active) {
                this.session = yield this.openSession(url);
            }
            else {
                this.session = new EmptySession();
            }
            return this.session;
        });
    }
}
exports.SessionService = SessionService;

'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = void 0;
const route_1 = require("../../public/route");
const express = require("express"); //see https://stackoverflow.com/a/34520891
const helper_1 = require("../helper");
const routes_parser_1 = require("./routes-parser");
const request_1 = require("./request");
const response_1 = require("./response");
const headers_1 = require("./headers");
const session_service_1 = require("./session-service");
const exception_1 = require("../exception");
const favicon_1 = require("../response-service/favicon");
// TODO: determine first request for a nicer logging and less frequent routes reloading
class Router {
    constructor(config, logService, fileUtils, responseService) {
        this.config = config;
        this.logService = logService;
        this.fileUtils = fileUtils;
        this.responseService = responseService;
        this.logging = logService.create('routing', this.config.routing.logging);
    }
    logRequest(request) {
        const userAgent = request.headers['user-agent'] || '';
        const isUserAgent = userAgent.includes('fhw-web');
        const wantsFavicon = request.originalUrl.includes('favicon');
        if (!isUserAgent && !wantsFavicon) {
            this.logging.data('Incomming Request:', request.method, request.originalUrl, helper_1.jsonStringify(request.post));
        }
    }
    logResponse(request, response) {
        const userAgent = request.headers['user-agent'] || '';
        const isUserAgent = userAgent.includes('fhw-web');
        const wantsFavicon = request.originalUrl.includes('favicon');
        if (!isUserAgent && !wantsFavicon) {
            this.logging.data('Sending Response', request.originalUrl, response.statusCode, response.type);
        }
    }
    plugIn(app) {
        return __awaiter(this, void 0, void 0, function* () {
            this.app = app;
            this.app.use((req, res, next) => __awaiter(this, void 0, void 0, function* () {
                const request = request_1.parseRequest(req);
                //TODO proper favicon handling
                if (request.originalUrl.endsWith('favicon.ico')) {
                    const favicon = Buffer.from(favicon_1.Favicon, 'base64');
                    res.writeHead(200, {
                        'Content-Type': 'image/png',
                        'Content-Length': favicon.length
                    });
                    res.end(favicon);
                }
                else {
                    this.logRequest(request);
                    if (this.config.routing.reloadOnEveryRequest) {
                        yield this.setup();
                    }
                    this.expRouter(req, res, next);
                }
            }));
            yield this.setup();
        });
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            this.expRouter = express.Router({ caseSensitive: true });
            const routesParser = new routes_parser_1.RoutesParser(this.config.routing, this.logging, this.fileUtils);
            const routes = yield routesParser.parseRoutesDefinitionFile();
            routes.forEach((route) => __awaiter(this, void 0, void 0, function* () {
                const methods = route.method || [route_1.DefaultMethod];
                methods.forEach((method) => __awaiter(this, void 0, void 0, function* () {
                    this.expRouter[method](route.url, (req, res, next) => __awaiter(this, void 0, void 0, function* () {
                        let response;
                        const request = request_1.parseRequest(req);
                        try {
                            const sessionService = new session_service_1.SessionService(this.config.sessions, this.logService.create('sessions', this.config.sessions.logging), this.fileUtils, req, res);
                            response = yield this.responseService.serve(route, request, sessionService);
                            response_1.checkResponse(response);
                            this.sendResponse(request, response, res);
                        }
                        catch (error) {
                            if (exception_1.isException(error)) {
                                if (error.getType() === exception_1.ExceptionType.ROUTE) {
                                    next();
                                }
                            }
                            else {
                                response = {
                                    type: 'text/html',
                                    statusCode: 500,
                                    html: yield this.responseService.serveErrorPage(error)
                                };
                                this.sendResponse(request, response, res);
                            }
                        }
                    }));
                }));
            }));
        });
    }
    /**
     * @important must not throw any error
     *
     * @param response FHW-Web-Response Object
     * @param res Express-Response Object
     */
    sendResponse(request, response, res) {
        if (helper_1.isDefined(response.headers)) {
            headers_1.setHeaders(res, response.headers);
        }
        res.status(response.statusCode);
        this.logResponse(request, response);
        switch (response.type) {
            case 'empty':
                res.sendStatus(response.statusCode);
                break;
            case 'text/plain':
                res.send(response.text);
                break;
            case 'static':
                res.sendFile(response.pathToFile);
                break;
            case 'text/html':
                res.send(response.html);
                break;
            case 'application/json':
                res.json(response.body);
                break;
            case 'redirect':
                res.redirect(response.redirectLocation);
                break;
        }
    }
}
exports.Router = Router;

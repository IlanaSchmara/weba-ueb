'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformValidation = exports.DEFAULT_LINE_DELIMITER = void 0;
const helper_1 = require("../helper");
const types_1 = require("./types");
exports.DEFAULT_LINE_DELIMITER = '| ';
class TransformValidation {
    constructor(lineDelimiter) {
        this.lineDelimiter = lineDelimiter;
        this.lineDelimiter = helper_1.isDefined(lineDelimiter)
            ? lineDelimiter
            : exports.DEFAULT_LINE_DELIMITER;
    }
    addLineNumbers(documentLines) {
        const amountOfLines = documentLines.length;
        const paddedCounter = new helper_1.PaddedCounter(1, amountOfLines - 1);
        const documentWithLineNumbers = documentLines.map(line => `${paddedCounter.next()}${this.lineDelimiter}${line}`);
        return [documentWithLineNumbers, paddedCounter.getMaxLength()];
    }
    determineColumnsToMark(y, numerationPad, lineLength, firstLine, lastLine, firstColumn, lastColumn) {
        let from = numerationPad + 1;
        let to = lineLength - 1;
        if ((y === firstLine) && (y === lastLine)) { //only one line
            from = numerationPad + firstColumn - 1;
            to = numerationPad + lastColumn - 1;
        }
        else if (y === firstLine) { //but multiline
            from = numerationPad + firstColumn - 1;
            to = lineLength - 1;
        }
        else if (y === lastLine) { //but multiline
            from = numerationPad + 1;
            to = numerationPad + lastColumn - 1;
        }
        return [from, to];
    }
    map(nuValidation, numerationPad, htmlWithLineNumbers, onTransformed) {
        const { type, subtype, message, extract, firstLine: _firstline, firstColumn: _firstColumn, lastLine, lastColumn, hiliteStart, hiliteLength } = nuValidation;
        const firstLine = !helper_1.isDefined(_firstline) ? lastLine : _firstline;
        const firstColumn = !helper_1.isDefined(_firstColumn) ? lastColumn : _firstColumn;
        const lines = [];
        for (let y = firstLine; y <= lastLine; ++y) {
            const loi = htmlWithLineNumbers[y - 1];
            let cleared = loi.split('\t').map(l => ' '.repeat(l.length)).join('\t');
            const [from, to] = this.determineColumnsToMark(y, numerationPad, loi.length, firstLine, lastLine, firstColumn, lastColumn);
            for (let x = from; x <= to; ++x) {
                if (cleared.charCodeAt(x) > 31) {
                    cleared = helper_1.replaceAt(cleared, x, '^');
                }
            }
            lines.push(loi);
            lines.push(cleared);
            onTransformed(y - 1, cleared);
        }
        return {
            type,
            typeMeaning: types_1.ValidationTypeMeaning[type],
            message,
            extract: lines
        };
    }
    transform(nuValidation, html) {
        const documentLines = html.split('\n');
        const [htmlWithLineNumbers, counterLength] = this.addLineNumbers(documentLines);
        const numerationPad = counterLength + this.lineDelimiter.length;
        const htmlWithExtraction = htmlWithLineNumbers.map(str => str); // copy string-array
        const results = nuValidation.map(nv => (this.map(nv, numerationPad, htmlWithLineNumbers, (line, transformed) => htmlWithExtraction[line] = `${htmlWithLineNumbers[line]}\n${transformed}`)));
        return {
            results,
            html: htmlWithExtraction.join('\n')
        };
    }
}
exports.TransformValidation = TransformValidation;

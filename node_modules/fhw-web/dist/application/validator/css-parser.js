'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CssParser = void 0;
const helper_1 = require("../helper");
const regex_1 = require("./regex");
class CssParser {
    constructor(fileUtils, request) {
        this.fileUtils = fileUtils;
        this.request = request;
    }
    fetchFromImportRule(path, css) {
        return __awaiter(this, void 0, void 0, function* () {
            let matches = Array.from(css.matchAll(regex_1.Regex.IMPORTED_CSS));
            const parseRegex = (regexMatch) => __awaiter(this, void 0, void 0, function* () {
                const [match, stylesheetName, mediaQuery] = regexMatch;
                const { path: _path } = this.fileUtils.parsePath(path);
                const stylesheetPath = helper_1.isDefined(path) ? this.fileUtils.join(_path, stylesheetName) : stylesheetName;
                const stylesheet = yield this.request.getStylesheet(stylesheetPath);
                const source = path.length > 0 ? path : 'inline style';
                return {
                    name: stylesheetName,
                    source: `imported via "${match} from stylesheet located in ${source}"`,
                    media: mediaQuery,
                    content: stylesheet
                };
            });
            const fetchingCss = matches.map(parseRegex);
            const fetchedCss = yield Promise.all(fetchingCss);
            return fetchedCss;
        });
    }
    fetchInlineStyles(html) {
        return __awaiter(this, void 0, void 0, function* () {
            let matches = Array.from(html.matchAll(regex_1.Regex.INLINE_CSS));
            const parseRegex = (regexMatch) => __awaiter(this, void 0, void 0, function* () {
                const [_, stylesheet] = regexMatch;
                const inlineCss = {
                    name: 'inline',
                    source: 'declared in html content',
                    media: null,
                    content: stylesheet
                };
                const importedCss = yield this.fetchFromImportRule('', stylesheet);
                return [inlineCss, ...importedCss];
            });
            const fetchingCss = matches.map(parseRegex);
            const fetchedCss = yield Promise.all(fetchingCss);
            return [].concat(...fetchedCss);
        });
    }
    fetchLinkedStyles(html) {
        return __awaiter(this, void 0, void 0, function* () {
            let matches = Array.from(html.matchAll(regex_1.Regex.LINKED_CSS));
            const parseRegex = (regexMatch) => __awaiter(this, void 0, void 0, function* () {
                const [match, stylesheetPath] = regexMatch;
                const stylesheet = yield this.request.getStylesheet(stylesheetPath);
                const linkedCss = {
                    name: stylesheetPath,
                    source: 'linked in html content',
                    media: null,
                    content: stylesheet
                };
                const importedCss = yield this.fetchFromImportRule(stylesheetPath, stylesheet);
                return [linkedCss, ...importedCss];
            });
            const fetchingCss = matches.map(parseRegex);
            const fetchedCss = yield Promise.all(fetchingCss);
            return [].concat(...fetchedCss);
        });
    }
    removeStyles(html) {
        const commentOut = (html) => `<!--${html}-->`;
        let htmlWithoutStyles = html.replace(regex_1.Regex.INLINE_CSS, commentOut);
        htmlWithoutStyles = htmlWithoutStyles.replace(regex_1.Regex.LINKED_CSS, commentOut);
        return htmlWithoutStyles;
    }
}
exports.CssParser = CssParser;

'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const css_parser_1 = require("./css-parser");
const regex_1 = require("./regex");
const transform_validation_1 = require("./transform-validation");
const helper_1 = require("../helper");
//TODO address the original line number in source file
class Validator {
    constructor(config, logging, fileUtils, request) {
        this.config = config;
        this.logging = logging;
        this.fileUtils = fileUtils;
        this.request = request;
        this.cssParser = new css_parser_1.CssParser(this.fileUtils, this.request);
        this.transformer = new transform_validation_1.TransformValidation();
    }
    addInlineStyles(html, styles) {
        const hint = 'For the validation all linked or imported css have been commented out and have been injected in the html by the framework automatically. Your stylesheets declarations have been commented out.';
        const css = styles.map(refCss => {
            const comment = `/* file: "${refCss.name}" source: "${refCss.source}" */`;
            const stylesheet = refCss.content.split('\n').map(line => `\t${line}`).join('\n');
            return `<style> ${comment}\n${stylesheet}\n</style>`;
        }).join('\n');
        const replace = `\n<!-- START INJECTION: ${hint} -->\n${css}\n<!-- END INJECTION -->$&`;
        const htmlWithStyles = html.replace(regex_1.Regex.CLOSING_HEAD_TAG, replace);
        return htmlWithStyles;
    }
    injectLinkedCss(html) {
        return __awaiter(this, void 0, void 0, function* () {
            const inlineCss = yield this.cssParser.fetchInlineStyles(html);
            const linkedCss = yield this.cssParser.fetchLinkedStyles(html);
            const allStyles = [...inlineCss, ...linkedCss];
            const htmlWithoutStyles = this.cssParser.removeStyles(html);
            const htmlWithAllStylesInline = this.addInlineStyles(htmlWithoutStyles, allStyles);
            return htmlWithAllStylesInline;
        });
    }
    _validate(html) {
        return __awaiter(this, void 0, void 0, function* () {
            const htmlWithAllStylesInline = yield this.injectLinkedCss(html);
            try {
                const validation = yield this.request.sendNuChecker(htmlWithAllStylesInline);
                return this.transformer.transform(validation, htmlWithAllStylesInline);
            }
            catch (error) {
                this.logging.error('Validation-Request failed', error);
            }
        });
    }
    validate(html) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.config.validation && helper_1.isDefined(html) && (typeof html === 'string')
                ? yield this._validate(html)
                : { results: [], html };
        });
    }
}
exports.Validator = Validator;

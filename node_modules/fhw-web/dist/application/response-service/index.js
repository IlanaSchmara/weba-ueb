'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseService = void 0;
const route_1 = require("../route");
const html_service_1 = require("./html-service");
const controller_service_1 = require("./controller-service");
const helper_1 = require("../helper");
const exception_1 = require("../exception");
const frontmatter_service_1 = require("../render-engine/frontmatter-service");
class ResponseService {
    constructor(config, logging, fileUtils, renderEngine, validator, databaseService) {
        this.config = config;
        this.logging = logging;
        this.fileUtils = fileUtils;
        this.renderEngine = renderEngine;
        this.validator = validator;
        this.databaseService = databaseService;
        this.htmlService = new html_service_1.HtmlService(this.config.routing, this.logging, this.fileUtils, this.renderEngine, this.validator);
        this.controllerService = new controller_service_1.ControllerService(this.config.templating, this.logging, this.fileUtils);
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            this.controllerService = yield this.controllerService.build();
            return this;
        });
    }
    serve(route, request, sessionService) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            if (route_1.isStaticRoute(route)) {
                response = yield this.serveStatic(route, request);
            }
            else {
                const globalData = yield this.databaseService.getGlobalData();
                const session = yield sessionService.getSession(request.originalUrl);
                if (route_1.isPageRoute(route)) {
                    const frontmatter = frontmatter_service_1.FrontmatterService.From({
                        request,
                        global: globalData,
                        session: session.getData()
                    });
                    response = yield this.servePage(route, frontmatter);
                }
                else if (route_1.isControllerRoute(route)) {
                    response = yield this.serveController(route, globalData, request, session);
                }
                else {
                    // TODO: double check when this happens
                    response = { type: 'empty', statusCode: 200 };
                }
                yield sessionService.closeSession(request);
                yield this.databaseService.save();
            }
            return response;
        });
    }
    serveErrorPage(error) {
        return __awaiter(this, void 0, void 0, function* () {
            const html = yield this.renderEngine.renderAnyError(error);
            return html;
        });
    }
    serveStatic(route, request) {
        return __awaiter(this, void 0, void 0, function* () {
            const relativePath = route_1.determineFilepath(route.static, request.path);
            const fullPath = this.fileUtils.fullPath(relativePath);
            if (!(yield this.fileUtils.fileExist(fullPath))) {
                throw exception_1.RouteException.NotFound(`The searched path is not a file or does not exist on filesystem: "${fullPath}"`);
            }
            return { type: 'static', statusCode: 200, pathToFile: fullPath };
        });
    }
    servePage(ressource, frontmatter) {
        return __awaiter(this, void 0, void 0, function* () {
            const pageHtml = yield this.htmlService.parsePage(ressource, frontmatter);
            const [valid, html] = yield this.htmlService.validate(pageHtml);
            if (valid) {
                return { statusCode: 200, type: 'text/html', html };
            }
            else {
                return { statusCode: 500, type: 'text/html', html };
            }
        });
    }
    serveFragment(ressource, frontmatter) {
        return __awaiter(this, void 0, void 0, function* () {
            const templateHtml = yield this.htmlService.parseTemplate(ressource, frontmatter);
            return { statusCode: 200, type: 'text/html', html: templateHtml };
        });
    }
    processControllerResult(result, globalData, request, session) {
        return __awaiter(this, void 0, void 0, function* () {
            if (controller_service_1.isTextResult(result)) {
                return { statusCode: result.status, type: 'text/plain', text: result.text };
            }
            else if (controller_service_1.isJsonResult(result)) {
                return { statusCode: result.status, type: 'application/json', body: result.json };
            }
            else if (controller_service_1.isRedirectResult(result)) {
                return { statusCode: result.status, type: 'redirect', redirectLocation: result.redirect };
            }
            else if (controller_service_1.isPageResult(result)) {
                const frontmatter = frontmatter_service_1.FrontmatterService.From({
                    request,
                    session,
                    global: globalData,
                    page: result.frontmatter
                });
                return this.servePage(result.page, frontmatter);
            }
            else if (controller_service_1.isFragmentResult(result)) {
                const frontmatter = frontmatter_service_1.FrontmatterService.From({
                    request,
                    session,
                    global: globalData,
                    page: result.frontmatter
                });
                return this.serveFragment(result.fragment, frontmatter);
            }
            else if (helper_1.isPromise(result)) {
                try {
                    const promiseResult = yield Promise.resolve(result);
                    return this.processControllerResult(promiseResult, globalData, request, session);
                }
                catch (err) {
                    throw new Error(`One of your controller rejected a promise: ${err})`);
                }
            }
            // TODO: double check when this happens
            // - case 1: when a returned chained promise does not get called
            return { type: 'empty', statusCode: 200 };
        });
    }
    serveController(route, globalData, request, session) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.routing.reloadOnEveryRequest) {
                this.controllerService = yield this.controllerService.build();
            }
            const frontmatter = frontmatter_service_1.FrontmatterService.From({
                global: globalData,
                request
            });
            const database = yield this.databaseService.getDatabase(frontmatter);
            try {
                const result = yield this.controllerService.callController(route, globalData, request, session, database);
                const response = this.processControllerResult(result, globalData, request, session.getData());
                return response;
            }
            catch (err) {
                throw new Error(`Your controller (function "${route.controller.function}" in file "${route.controller.file}") threw the following error: ${err}`);
            }
        });
    }
}
exports.ResponseService = ResponseService;

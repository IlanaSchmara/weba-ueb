'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleLoader = exports.ModuleExtension = void 0;
const typescript_1 = require("typescript");
var ModuleExtension;
(function (ModuleExtension) {
    ModuleExtension["JS"] = "js";
    ModuleExtension["TS"] = "ts";
})(ModuleExtension = exports.ModuleExtension || (exports.ModuleExtension = {}));
class ModuleLoader {
    constructor(logging, fileUtils) {
        this.logging = logging;
        this.fileUtils = fileUtils;
    }
    listModules(directory, recursively = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const filenames = yield this.fileUtils.listFiles({ directory, recursively });
            const jsModulenames = filenames.filter(filename => filename.includes(ModuleExtension.JS));
            const tsModulenames = filenames.filter(filename => filename.includes(ModuleExtension.TS));
            return {
                [ModuleExtension.JS]: jsModulenames,
                [ModuleExtension.TS]: tsModulenames
            };
        });
    }
    parseTypescriptModule(filename, tsContent) {
        const jsContent = typescript_1.transpileModule(tsContent, {
            fileName: filename,
            compilerOptions: {
                alwaysStrict: true,
                module: typescript_1.ModuleKind.CommonJS,
                target: typescript_1.ScriptTarget.ES2015,
                skipLibCheck: true,
                experimentalDecorators: true
            }
        });
        return jsContent.outputText;
    }
    createModule(filename, content) {
        if (filename.includes(ModuleExtension.TS)) {
            content = this.parseTypescriptModule(filename, content);
        }
        // note: it has to be declared as an any-type, so it can be constructed
        // @see https://stackoverflow.com/a/41017777
        const Module = module.constructor;
        const m = new Module(); //note: this expression, in fact, is constructable
        m._compile(content, filename);
        return m.exports;
    }
    _openModules(parseModuleExports, directory, recursively = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const modulenames = yield this.listModules(directory, recursively);
            const allModuleNames = [...modulenames[ModuleExtension.JS], ...modulenames[ModuleExtension.TS]];
            const promisedModules = allModuleNames
                .map((filename) => __awaiter(this, void 0, void 0, function* () { return yield this.fileUtils.readFile(filename, directory); }));
            const modules = (yield Promise.all(promisedModules))
                .map((script, index) => {
                const filename = allModuleNames[index];
                const module = this.createModule(filename, script);
                const result = {
                    name: filename,
                    _exports: parseModuleExports(module)
                };
                return result;
            });
            return modules;
        });
    }
    openModules(parseModuleExports, directory, recursively = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const folderExists = yield this.fileUtils.exist(directory);
            return folderExists
                ? this._openModules(parseModuleExports, directory, recursively)
                : [];
        });
    }
}
exports.ModuleLoader = ModuleLoader;

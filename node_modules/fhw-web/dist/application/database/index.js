'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseService = void 0;
const global_data_service_1 = require("./global-data-service");
const file_data_service_1 = require("./file-data-service");
const sql_data_service_1 = require("./sql-data-service");
class Database {
    constructor(loadJson, saveJson, executeSql) {
        this.loadJson = loadJson;
        this.saveJson = saveJson;
        this.executeSql = executeSql;
    }
}
// import sequelize
// TODO: yaml global.yaml should be possible
// TODO: json and sqlite databases are possible
// read from config which to choose and to deliver
// ==> need for generic functions to open/save json and to run sql statements
class DatabaseService {
    constructor(config, logService, fileUtils) {
        this.config = config;
        this.logService = logService;
        this.fileUtils = fileUtils;
        this.sqlDataService = new sql_data_service_1.SqlDataService(this.config.sqliteData, this.logService.create('sql-data', this.config.sqliteData.logging), this.fileUtils);
        this.globalDataService = new global_data_service_1.GlobalDataService(this.config.globalData, this.logService.create('global-data', this.config.globalData.logging), this.fileUtils, this.sqlDataService);
        this.fileDataService = new file_data_service_1.FileDataService(this.config.fileData, this.logService.create('file-data', this.config.fileData.logging), this.fileUtils);
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.sqlDataService.build();
            yield this.globalDataService.build();
            yield this.fileDataService.build();
            return this;
        });
    }
    reload() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.globalDataService.reload();
            yield this.fileDataService.reload();
            yield this.sqlDataService.reload();
        });
    }
    getGlobalData() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.globalDataService.getData();
        });
    }
    getDatabase(frontmatter) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = Object.assign({}, frontmatter.page, frontmatter.request.path, frontmatter.request.get, frontmatter.request.post);
            return new Database((filename) => this.fileDataService.loadJson(filename), (filename, data) => this.fileDataService.saveJson(filename, data), (sql) => this.sqlDataService.query(sql, params));
        });
    }
    parseAndExecuteSql(obj, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sqlDataService.parseAndExecuteSql(obj, params);
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fileDataService.save();
            yield this.sqlDataService.save();
        });
    }
}
exports.DatabaseService = DatabaseService;

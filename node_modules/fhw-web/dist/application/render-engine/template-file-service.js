'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateFile = exports.TemplateFileService = exports.TemplateType = void 0;
const exception_1 = require("../exception");
const frontmatter_service_1 = require("./frontmatter-service");
var TemplateType;
(function (TemplateType) {
    TemplateType[TemplateType["PAGE"] = 0] = "PAGE";
    TemplateType[TemplateType["TEMPLATE"] = 1] = "TEMPLATE";
})(TemplateType = exports.TemplateType || (exports.TemplateType = {}));
class TemplateFileService {
    constructor(config, fileUtils, databaseService) {
        this.config = config;
        this.fileUtils = fileUtils;
        this.databaseService = databaseService;
    }
    findExtension(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const acceptedExtensions = yield Promise.all(this.config.allowedExtensions.map((ext) => __awaiter(this, void 0, void 0, function* () {
                return yield this.fileUtils.exist(`${path}.${ext}`);
            })));
            if (acceptedExtensions.indexOf(true) === -1) {
                throw new Error(`Can not find file on filesystem with any of the valid file extensions(${this.config.allowedExtensions}): ${path}`);
            }
            const extension = this.config.allowedExtensions[acceptedExtensions.indexOf(true)];
            return extension;
        });
    }
    readFile(filepath) {
        return __awaiter(this, void 0, void 0, function* () {
            let path = this.fileUtils.fullPath(filepath);
            path = (yield this.fileUtils.isDirectory(path))
                ? this.fileUtils.join(path, 'index')
                : path;
            path = this.fileUtils.hasExtension(path)
                ? path
                : `${path}.${yield this.findExtension(path)}`;
            if (!(yield this.fileUtils.fileExist(path))) {
                throw exception_1.RouteException.NotFound(`Can not find requested file: ${path}`);
            }
            const file = yield this.fileUtils.readFile(path);
            return file;
        });
    }
    build(filepath, type, parentFrontmatter) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (type) {
                case TemplateType.PAGE:
                    filepath = this.fileUtils.join(this.config.paths.pages, filepath);
                    break;
                case TemplateType.TEMPLATE:
                    filepath = this.fileUtils.join(this.config.paths.templates, filepath);
                    break;
            }
            const file = yield this.readFile(filepath);
            const templateFile = (new TemplateFile(filepath, this.databaseService, file)).build(parentFrontmatter);
            return templateFile;
        });
    }
    from(fileContent, parentFrontmatter) {
        return __awaiter(this, void 0, void 0, function* () {
            const templateFile = yield (new TemplateFile('from memory', this.databaseService, fileContent)).build(parentFrontmatter);
            return templateFile;
        });
    }
}
exports.TemplateFileService = TemplateFileService;
class TemplateFile {
    constructor(name, databaseService, file) {
        this.name = name;
        this.databaseService = databaseService;
        this.file = file;
    }
    validateFrontmatterType(fmatterType) {
        // TODO validate fmatterType
    }
    transformFrontmatter(fmatter, parent) {
        return __awaiter(this, void 0, void 0, function* () {
            const fmatterMerged = frontmatter_service_1.FrontmatterService.Merge(parent, fmatter);
            const params = Object.assign(Object.assign(Object.assign(Object.assign({}, fmatterMerged.global), fmatterMerged.session), fmatterMerged.page), fmatterMerged.request);
            return yield this.databaseService.parseAndExecuteSql(fmatter, params);
        });
    }
    build(parentFrontmatter) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO check this.file != null
            this.parentFrontmatter = parentFrontmatter;
            const fmatterRegex = /(?:---)([\s\S]*?)(?:---)/g;
            let matching = fmatterRegex.exec(this.file);
            if (matching) { // frontmatter there
                const [_, rawFmatter] = matching;
                const [fmatter, fmatterType] = frontmatter_service_1.FrontmatterService.FromRawString(rawFmatter.trim());
                this.validateFrontmatterType(fmatterType);
                this.frontmatter = yield this.transformFrontmatter(fmatter, parentFrontmatter);
                const markupRegex = /(?:---[\s\S]*?---)([\s\S]*)/g;
                matching = markupRegex.exec(this.file);
                if (matching) {
                    const [_, rawMarkup] = matching;
                    this.markup = rawMarkup.trim();
                }
                else {
                    this.markup = '';
                }
            }
            else { // no frontmatter
                this.markup = this.file.trim();
            }
            return this;
        });
    }
    getFrontmatter() {
        return frontmatter_service_1.FrontmatterService.Merge(this.parentFrontmatter, this.frontmatter);
    }
    getMarkup() {
        return this.markup;
    }
    getName() {
        return this.name;
    }
}
exports.TemplateFile = TemplateFile;

'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontmatterService = void 0;
const route_1 = require("../../public/route");
const frontmatter_1 = require("../../public/frontmatter");
const helper_1 = require("../helper");
class FrontmatterService {
    static CreateEmpty() {
        return {
            global: {},
            page: {},
            request: {
                get: {}, post: {}, path: {},
                method: route_1.DefaultMethod, url: '',
                originalUrl: '', ip: '', headers: {}
            },
            session: { id: '' }
        };
    }
    static Merge(parent, page) {
        return {
            global: parent.global,
            page: Object.assign(Object.assign({}, parent.page), page),
            request: Object.assign({}, parent.request),
            session: Object.assign({}, parent.session),
        };
    }
    static From(fm) {
        const empty = FrontmatterService.CreateEmpty();
        const request = helper_1.isDefined(fm.request)
            ? {
                get: fm.request.get || empty.request.get,
                post: fm.request.post || empty.request.post,
                path: fm.request.path || empty.request.path,
                method: fm.request.method || empty.request.method,
                url: fm.request.url || empty.request.url,
                originalUrl: fm.request.originalUrl || empty.request.originalUrl,
                ip: fm.request.ip || empty.request.ip,
                headers: fm.request.headers || empty.request.headers
            }
            : empty.request;
        return {
            global: fm.global || empty.global,
            page: fm.page || empty.page,
            request: request,
            session: fm.session || empty.session
        };
    }
    //  TODO result type and actual value are not matching everytime
    static FromRawString(raw) {
        let error = null;
        try {
            const asJson = helper_1.parseJson(raw);
            return [asJson, frontmatter_1.FrontmatterTypes.JSON];
        }
        catch (err) {
            error = err;
        }
        try {
            const asYaml = helper_1.parseYaml(raw);
            return [asYaml, frontmatter_1.FrontmatterTypes.YAML];
        }
        catch (_) { }
        // TODO: determine whenever json or yaml is requested and print the corresponding error output, if present
        // TODO: provide a link to a json or yaml online parser with beautiful error recognition
        throw new Error(`Invalid Frontmatter-Format: ${error}`);
    }
}
exports.FrontmatterService = FrontmatterService;
